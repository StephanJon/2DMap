\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{hhline}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{multicol}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm
\renewcommand\baselinestretch{1.0}

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

%% Comments

\usepackage{color}

\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{blue}{SS}{#1}}

\title{Assignment 3, Part 1, Specification}
\author{SFWR ENG 2AA4}

\begin {document}

\maketitle

The purpose of this software design exercise is to design and implement a
portion of the specification for a Geographic Information System (GIS).  This
document shows the complete specification, which will be the basis for your
implementation and testing.  In this specification natural numbers
($\mathbb{N}$) include zero ($0$).

\wss{The parts that you need to fill in are marked by comments, like this one.
  In several of the modules local functions are specified.  You can use these
  local functions to complete the missing specifications.}

\newpage

\section* {Map Types Module}

\subsection*{Module}

MapTypes

\subsection* {Uses}

N/A

\subsection* {Syntax}

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Types}

CompassT = \{N, S, E, W\}\\ 
LanduseT = \{Recreational, Transport, Agricultural, Residential, Commercial\}\\
RotateT = \{CW, CCW\}

\subsubsection* {Exported Access Programs}

None

\subsection* {Semantics}

\subsubsection* {State Variables}

None

\subsubsection* {State Invariant}

None

\newpage

\section* {Point ADT Module}

\subsection*{Template Module}

PointT

\subsection* {Uses}

N/A

\subsection* {Syntax}

\subsubsection* {Exported Types}

\wss{PointT = ?}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
PointT & $\mathbb{Z}$, $\mathbb{Z}$ & PointT & \\
\hline
x & ~ & $\mathbb{Z}$ & ~\\
\hline
y & ~ & $\mathbb{Z}$ & ~\\
\hline
translate & $\mathbb{Z}$, $\mathbb{Z}$ & PointT & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$xc$: \wss{$\mathbb{Z}$}\\
$yc$: \wss{$\mathbb{Z}$}

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

The constructor PointT is called for each object instance before any other
access routine is called for that object.  The constructor cannot be called on
an existing object.

\subsubsection* {Access Routine Semantics}

PointT($x, y$):
\begin{itemize}
\item transition: \wss{xc, yc := x, y}
\item output: $out := \mathit{self}$
\item exception: None
\end{itemize}

\noindent x():
\begin{itemize}
\item output: $out := xc$
\item exception: None
\end{itemize}

\noindent y():
\begin{itemize}
\item output: $out := yc$
\item exception: None
\end{itemize}

\noindent translate($\Delta x$, $\Delta y$):
\begin{itemize}
\item \wss{output: out: PointT(xc + $\Delta x$, yc + $\Delta y$)}
\item exception: None
\end{itemize}

\newpage

\section* {Line ADT Module}

\subsection*{Template Module}

LineT

\subsection* {Uses}

\wss{PointT, MapTypes for CompassT and RotateT}

\subsection* {Syntax}

\subsubsection* {Exported Types}

LineT = ?

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
LineT & PointT, CompassT, $\mathbb{N}$ & LineT & invalid\_argument\\
\hline
strt & ~ & PointT & ~\\
\hline
end & ~ & PointT & ~\\
\hline
orient & ~ & CompassT & ~\\
\hline
 len & ~ & $\mathbb{Z}$ & ~\\
\hline
flip & ~ & LineT & ~\\
\hline
rotate & RotateT & LineT & ~\\
\hline
translate & $\mathbb{Z}$, $\mathbb{Z}$ & LineT  & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$s$: PointT\\
$o$: CompassT\\
$L$: $\mathbb{N}$\\ 

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

The constructor LineT is called for each object instance before any other
access routine is called for that object.  The constructor cannot be called on
an existing object.

\subsubsection* {Access Routine Semantics}

LineT($st, ornt, l$):
\begin{itemize}
\item transition: $s, o, L := st, ornt, l$
\item output: $out := \mathit{self}$
\item exception: \wss{$l \leq 0 \implies invalid\_argument$}
\end{itemize}

\noindent strt():
\begin{itemize}
\item output: $out := \mbox{PointT}(st.x, st.y)$
\item exception: None
\end{itemize}

\noindent end():
\begin{itemize}
\item output: \wss{$PointT(x, y)\, where,\, ( (o = N \implies y = strt().y() + l) \| (o = S \implies y = strt().y() - l) \| (o = E \implies y = strt().x() + l) \| (o = W \implies y = strt().x() - l) )$}

\item exception: None
\end{itemize}

\noindent orient():
\begin{itemize}
\item output: $out := o$
\item exception: None
\end{itemize}

\noindent len():
\begin{itemize}
\item output: $out := L$
\item exception: None
\end{itemize}

\noindent flip():
\begin{itemize}
\item output: \wss{LineT(strt(), o, $l$)\, where,\, (o = rotate(CW), o = rotate(CW))}
\item exception: None
\end{itemize}

\noindent rotate(r):
\begin{itemize}
\item output: 
\begin{tabular}{|p{2.cm}|p{2.3cm}|l|}
\hhline{~|~|-|}
\multicolumn{1}{r}{} & \multicolumn{1}{r|}{} & \multicolumn{1}{l|}{$out :=$}\\
\hhline{|-|-|-|}
$r = \mbox{CW}$ & $o = \mbox{N}$ & \wss{E}\\
\hhline{|~|-|-|}
~ & $o = \mbox{S}$ & \wss{W}\\
\hhline{|~|-|-|}
~ & $o = \mbox{W}$ & \wss{N}\\
\hhline{|~|-|-|}
~ & $o = \mbox{E}$ & \wss{S}\\
\hhline{-|-|-|}
$r = \mbox{CCW}$ & $o = \mbox{N}$ & \wss{W}\\
\hhline{|~|-|-|}
~ & $o = \mbox{S}$ & \wss{E}\\
\hhline{|~|-|-|}
~ & $o = \mbox{W}$ & \wss{S}\\
\hhline{|~|-|-|}
~ & $o = \mbox{E}$ & \wss{N}\\
\hhline{-|-|-|}
\end{tabular}

\item exception: None
\end{itemize}

\noindent translate($\Delta x$, $\Delta y$):
\begin{itemize}
\item output: \wss{LineT(newPoint, o, $l$)\, where,\, (newPoint = st.translate($\Delta x$, $\Delta y$)}
\item exception: None
\end{itemize}

\newpage

\section* {Path ADT Module}

\subsection*{Template Module}

PathT

\subsection* {Uses}

PointT, LineT, MapTypes

\subsection* {Syntax}

\subsubsection* {Exported Types}

PathT = ?

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
PathT & PointT, CompassT, $\mathbb{N}$ & PathT & \\ %LineT constructor for invalid\_argument
\hline
append & CompassT, $\mathbb{N}$ & & invalid\_argument\\ 
\hline
strt & ~ & PointT & ~\\
\hline
end & ~ & PointT & ~\\
\hline
line & $\mathbb{N}$ & LineT & outside\_bounds\\
\hline
size & ~ & $\mathbb{N}$ & \\
\hline
 len & ~ & $\mathbb{N}$ & ~\\
\hline
translate & $\mathbb{Z}$, $\mathbb{Z}$ & LineT  & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$s$: sequence of LineT

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

\begin{itemize}
\item The constructor PathT is called for each object instance before any other
access routine is called for that object.  The constructor cannot be called on
an existing object.
%\item Appends will not be made while iterating through the list of lines.
\end{itemize}

\subsubsection* {Access Routine Semantics}

PathT($st, ornt, l$):
\begin{itemize}
\item transition: \wss{$s_{0}$ := LineT($st, ornt, l$)}
\item output: $out := \mathit{self}$
\item exception: None
\end{itemize}

\noindent append($ornt, l$):
\begin{itemize}
\item transition: \wss{s := s + LineT($z, ornt, l$)\, where,\, ($z = adjPt(ornt)$).}
\item exception: \wss{$s_{|s|-1}.rotate(CW).rotate(CW).orient  = ornt \implies invalid\_argument$}
\end{itemize}

\noindent strt():
\begin{itemize}
\item output: \wss{out:= $s_{0}.st$}
\item exception: None
\end{itemize}

\noindent end():
\begin{itemize}
\item output: \wss{out:= $s_{|s|-1}.end$}
\item exception: None
\end{itemize}

\noindent line($i$):
\begin{itemize}
\item output: \wss{out := $s_{i}$}
\item exception: \wss{$i < 0 \| i \geq s.len \implies outside\_bounds$}
\end{itemize}

\noindent size:
\begin{itemize}
\item output: \wss{out := $s.len$}
\item exception: None
\end{itemize}

\noindent len:
\begin{itemize}
\item output: \wss{$out := +\forall(i : \mathbb{N}|i\in[0...s.len-1] : pointsInLine(i))$}
\item exception: None
\end{itemize}

\noindent translate($\Delta x$, $\Delta y$):
\begin{itemize}
\item output: Create a new PathT object with state variable $s'$ such that:
$$\forall(i: \mathbb{N} | i \in [0..|s|-1] : s'[i] = s[i].\mbox{translate}(\Delta x, \Delta y))$$
\item exception: None
\end{itemize}

\subsection*{Local Functions}

pointsInLine: $\mbox{LineT} \rightarrow \mbox{(set of PointT)}$\\

\noindent pointsInLine ($l$) 
\begin{multline*}
\equiv \{ i: \mathbb{N} | i \in [0
  .. (l.\mbox{len} - 1)] : l.\mbox{strt}.\mbox{translate}.(
\end{multline*} (\wss{\begin{tabular}{|l|l|}
\hline
$l.orient = \mbox{N}$ & $(0,1)$\\
\hline
$l.orient = \mbox{S}$ & $(0,-1)$\\
\hline
$l.orient = \mbox{W}$ & $(-1,0)$\\
\hline
$l.orient = \mbox{E}$ & $(1,0)$\\
\hline
\end{tabular}}

\noindent adjPt: $\mbox{CompassT} \rightarrow \mbox{PointT}$\\
adjPt$(ornt) \equiv$

\medskip

\begin{tabular}{|l|l|}
\hline
$ornt = \mbox{N}$ & $s[|s|-1].\mbox{end}.\mbox{translate}\wss{(0,1)}$\\
\hline
$ornt = \mbox{S}$ & $s[|s|-1].\mbox{end}.\mbox{translate}\wss{(0,-1)}$\\
\hline
$ornt = \mbox{W}$ & $s[|s|-1].\mbox{end}.\mbox{translate}\wss{(-1,0)}$\\
\hline
$ornt = \mbox{E}$ & $s[|s|-1].\mbox{end}.\mbox{translate}\wss{(1,0)}$\\
\hline
\end{tabular}

\newpage

\section* {Generic Seq2D Module}

\subsection* {Generic Template Module}

Seq2D(T)

\subsection* {Uses}

N/A

\subsection* {Syntax}

\subsubsection* {Exported Types}

Seq2D(T) = ?

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
Seq2D & seq of (seq of T), $\mathbb{R}$ & Seq2D & invalid\_argument\\
\hline
set & PointT, T & ~ & outside\_bounds\\
\hline
get & PointT & T & outside\_bounds\\
\hline
getNumRow & ~ & $\mathbb{N}$ & \\
\hline
getNumCol & ~ & $\mathbb{N}$ & \\
\hline
getScale & ~ & $\mathbb{R}$ & \\
\hline
count & T & $\mathbb{N}$ & \\
\hline
count & LineT, T & $\mathbb{N}$ & invalid\_argument\\
\hline
count & PathT, T & $\mathbb{N}$ & invalid\_argument\\
\hline
length & PathT & $\mathbb{R}$ & invalid\_argument\\
\hline
connected & PointT, PointT & $\mathbb{B}$ & invalid\_argument\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$s$: seq of (seq of T)\\
scale: $\mathbb{R}$\\
nRow: $\mathbb{N}$\\
nCol: $\mathbb{N}$

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

\begin{itemize}
\item The Seq2D(T) constructor is called for each object instance before any
other access routine is called for that object.  The constructor can only be
called once.
\item Assume that the input to the constructor is a sequence of rows, where each
  row is a sequence of elements of type T.  The number of columns (number of
  elements) in each row is assumed to be equal. That is each row
  of the grid has the same number of entries.  $s[i][j]$ means the ith row and
  the jth column.  The 0th row is at the bottom of the map and the 0th column
  is at the leftmost side of the map.
\end{itemize}

\subsubsection* {Access Routine Semantics}

Seq2D($S$, scl):
\begin{itemize}
\item transition: \wss{s, scale, nRow, nCol := S, scl, S.len, S[0].len}
\item output: $\mathit{out} := \mathit{self}$
\item exception: \wss{$scl < 0 \| \lnot(validRow) \| \lnot(validCol) \| S.len \neq S[0].len \implies invalid\_argument$}
\end{itemize}

\noindent set($p, v$):
\begin{itemize}
\item transition: \wss{s[p.y][p.x] := v}
\item exception: \wss{$p.y < 0 \| p.x < 0 \| p.y \geq nRow \| p.x \geq nCol \implies outside\_bounds$}
\end{itemize}

\noindent get($p$):
\begin{itemize}
\item output: \wss{out:= s[p.y][p.x]}
\item exception: \wss{$p.y < 0 \| p.x < 0 \| p.y \geq nRow \| p.x \geq nCol \implies outside\_bounds$}
\end{itemize}

\noindent getNumRow():
\begin{itemize}
\item output: $out := \mbox{nRow}$
\item exception: None
\end{itemize}

\noindent getNumCol():
\begin{itemize}
\item output: $out := \mbox{nCol}$
\item exception: None
\end{itemize}

\noindent getScale():
\begin{itemize}
\item output: $out := \mbox{scale}$
\item exception: None
\end{itemize}

\noindent count($t$: T):
\begin{itemize}
\item output: \wss{$out:= +(\forall i : \mathbb{N} | i \in [0...nRow] \bullet \forall j : \mathbb{N} | j \in [0...nCol] \bullet s[i][j] = t : 1)$}
\item exception: None
\end{itemize}

\noindent count($l$: LineT, $t$: T):
\begin{itemize}
\item output: \wss{$out:= +(\forall i : \mathbb{N} | i \in [l.strt.y...l.end.y] \bullet \forall j : \mathbb{N} | j \in [l.strt.x...l.end.x] \bullet s[i][j] = t : 1$}
\item exception: \wss{$\lnot(validLine(l)) \implies invalid\_argument$}
\end{itemize}

\noindent count($\mathit{pth}$: PathT, $t$: T):
\begin{itemize}
\item output: \wss{$out:= +(\forall k :\mathbb{N} | k \in [0...pth.size-1] \bullet \forall i : \mathbb{N} | i \in [pth[k].strt.y...pth[k].end.y] \bullet \forall j : \mathbb{N} | j \in [pth[k].strt.x...pth[k].end.x] \bullet s[i][j] = t : 1$}
\item exception: \wss{$\lnot(validPath(pth)) \implies invalid\_argument$}
\end{itemize}

\noindent length($\mathit{pth}$: PathT):
\begin{itemize}
\item output: \wss{$out := scl \times pth.len$}
\item exception: \wss{$\lnot(validPath(pth)) \implies invalid\_argument$}
\end{itemize}

\noindent connected($p_1$: PointT, $p_2$: PointT):
\begin{itemize}
\item output: \wss{$out := ((\forall k : \mathbb{N} | k \in [0...pth.size - 1] | \bullet \exists p_1 : PointT | \bullet pointsInPath(pth)[k] = p_1) \land (\forall k : \mathbb{N} | k \in [0...pth.size - 1] | \bullet \exists p_2 : PointT | \bullet pointsInPath(pth)[k] = p_2)) \implies true$}
\item exception: \wss{$\lnot(validPoints(p_1) \land validPoints(p_2)) \implies invalid\_argument)$}

\end{itemize}

\subsection*{Local Functions}

\noindent validRow: $\mathbb{N} \rightarrow \mathbb{B}$\\
\noindent \wss{validRow(i) $\equiv$ $0 < i < nRow = true$, where i $\rightarrow \mathbb{N}$}\\

\noindent validCol: $\mathbb{N} \rightarrow \mathbb{B}$\\
\noindent \wss{validCol(i) $\equiv$ $0 < i < nCol = true$, where i $\rightarrow \mathbb{N}$}\\

\noindent validPoint: $\mbox{PointT} \rightarrow \mathbb{B}$\\
\noindent \wss{validPoint(point) $\equiv$ $(point.x \land point.y) \geq 0\, \land (point.x \land point.y) < (nRow \land nCol) \implies true$,\, where\, point $\rightarrow$ PointT}\\

\noindent validLine: $\mbox{LineT} \rightarrow \mathbb{B}$\\
\noindent \wss{validLine(i) $\equiv$ $(validPoint(l.strt) \land validPoint(l.end))  \implies true$,\, where\, $l \rightarrow$ LineT}\\

\noindent validPath: $\mbox{PathT} \rightarrow \mathbb{B}$\\
\noindent \wss{validPath(i) $\equiv$ $\forall : \mathbb{N} | k \in [0...pth.size - 1] \bullet (validLine(pth[k])) \implies true$,\, where\, pth $\rightarrow$ PathT}\\

\noindent pointsInLine: $\mbox{LineT} \rightarrow \mbox{(set of PointT)}$\\
\noindent pointsInLine ($l$) 
\wss{pointsInLine($l$) $\equiv$  $i: \mathbb{N} | i \in [0 .. (l.len - 1)] : l.strt.translate($ \begin{tabular}{|l|l|}
\hline
$l.orient = \mbox{N}$ & $(0,1)$\\
\hline
$l.orient = \mbox{S}$ & $(0,-1)$\\
\hline
$l.orient = \mbox{W}$ & $(-1,0)$\\
\hline
$l.orient = \mbox{E}$ & $(1,0)$\\
\hline
\end{tabular})}

\noindent pointsInPath: $\mbox{PathT} \rightarrow \mbox{(set of PointT)}$\\
\wss{pointsInPath(p) $\equiv$ $\cup$$(k: \mathbb{N} | k \in [0 .. (p.size - 1)] : (pointsInLine(p[k])))$,\, where\, p $\rightarrow$ PathT}
\noindent pointsInPath($p$) 

\newpage

\section* {LanduseMap Module}

\subsection* {Template Module}

LanduseMapT is Seq2D(LanduseT)

\section* {DEM Module}

\subsection* {Template Module}

DEMT is Seq2D($\mathbb{Z}$)

\newpage

\section*{Critique of Design}

In general, the specifications were easy to follow. However, one thing that could be added are hints to use the local functions for certain exceptions earlier on in each module because some time was wasted to create exceptions beforehand, only to realize that one could use the local functions as exceptions.

\end {document}